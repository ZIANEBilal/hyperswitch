let dashboardData = null;
let connectorChart = null;
let distributionChart = null;
const executionTimeChart = null;
let avgDurationChart = null;
function toPascalCase(str) {
  return str
    .toLowerCase()
    .split("_")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join("");
}
document.addEventListener("DOMContentLoaded", () => {
  loadTheme();
  loadDashboardData();
  setupEventListeners();
  setInterval(loadDashboardData, 30000);
});
function setupEventListeners() {
  document
    .getElementById("refreshBtn")
    .addEventListener("click", loadDashboardData);
  document.getElementById("themeToggle").addEventListener("click", toggleTheme);
  document
    .getElementById("connectorFilter")
    .addEventListener("change", filterData);
  document
    .getElementById("statusFilter")
    .addEventListener("change", filterData);
  const modal = document.getElementById("testRunnerModal");
  const closeBtn = document.getElementsByClassName("close")[0];
  closeBtn.onclick = () => {
    modal.style.display = "none";
  };
  window.onclick = (event) => {
    if (event.target === modal) {
      modal.style.display = "none";
    }
  };
  document
    .getElementById("runTestBtn")
    .addEventListener("click", runIndividualTest);
  document
    .getElementById("testConnector")
    .addEventListener("change", updateTestFiles);
  document
    .getElementById("testFile")
    .addEventListener("change", updateTestCases);
}
async function loadDashboardData() {
  try {
    const response = await fetch("cypress/reports/dashboard-data.json");
    if (!response.ok) {
      throw new Error("Failed to load dashboard data");
    }
    dashboardData = await response.json();
    updateDashboard();
  } catch (error) {
    console.error("Error loading dashboard data:", error);
    showError(
      "Failed to load dashboard data. Make sure to run the report generator first."
    );
  }
}
function updateDashboard() {
  if (!dashboardData) return;
  document.getElementById("lastUpdated").textContent =
    `Last Test Run: ${new Date(dashboardData.timestamp).toLocaleString()}`;
  updateSummaryCards();
  updateCharts();
  updateConnectorFilters();
  filterData();
  setupFailedTestsCollapsible();
}
function updateSummaryCards() {
  const activeConnectors = Object.entries(dashboardData.connectors).filter(
    ([, data]) => data.totalTests > 0
  ).length;
  document.getElementById("totalConnectors").textContent = activeConnectors;
  const totalSkippedPending =
    dashboardData.totalSkipped + dashboardData.totalPending;
  document.getElementById("totalTests").textContent = dashboardData.totalTests;
  document.getElementById("totalPassed").textContent =
    dashboardData.totalPassed;
  document.getElementById("totalFailed").textContent =
    dashboardData.totalFailed;
  document.getElementById("totalSkipped").textContent = totalSkippedPending;
  document.getElementById("successRate").textContent =
    `${dashboardData.overallSuccessRate}%`;
  const failureRate =
    dashboardData.totalTests > 0
      ? ((dashboardData.totalFailed / dashboardData.totalTests) * 100).toFixed(
          2
        )
      : 0;
  document.getElementById("failureRate").textContent = `${failureRate}%`;
  document.getElementById("executionTime").textContent = formatDuration(
    dashboardData.executionTime
  );
}
function formatDuration(ms) {
  const seconds = Math.floor(ms / 1000);
  const minutes = Math.floor(seconds / 60);
  const hours = Math.floor(minutes / 60);
  if (hours > 0) {
    return `${hours}h ${minutes % 60}m`;
  } else if (minutes > 0) {
    return `${minutes}m ${seconds % 60}s`;
  } else {
    return `${seconds}s`;
  }
}
function getChartColors() {
  const isDark = document.body.classList.contains("dark-theme");
  return {
    textColor: isDark ? "#e0e0e0" : "#212529",
    gridColor: isDark ? "#2d2d2d" : "#e9ecef",
    executionLineColor: "#f59e0b",
    scales: {
      x: {
        ticks: { color: isDark ? "#e0e0e0" : "#212529" },
        grid: { color: isDark ? "#2d2d2d" : "#e9ecef" },
      },
      y: {
        ticks: { color: isDark ? "#e0e0e0" : "#212529" },
        grid: { color: isDark ? "#2d2d2d" : "#e9ecef" },
      },
    },
  };
}
function updateCharts() {
  updateCombinedChart();
  updateDistributionChart();
  updateAvgDurationChart();
}
function updateCombinedChart() {
  const ctx = document.getElementById("connectorChart").getContext("2d");
  const colors = getChartColors();
  const activeConnectors = Object.entries(dashboardData.connectors).filter(
    ([, data]) => data.totalTests > 0
  );
  const connectorNames = activeConnectors.map(([name]) => name);
  const executionTimes = connectorNames.map((c) => {
    const connector = dashboardData.connectors[c];
    const totalTime = connector.executionTime || 0;
    return (totalTime / 1000 / 60).toFixed(2);
  });
  const datasets = [
    {
      label: "Passed",
      data: connectorNames.map((c) => dashboardData.connectors[c].passed),
      backgroundColor: "#04c38d",
      stack: "tests",
      yAxisID: "y",
    },
    {
      label: "Failed",
      data: connectorNames.map((c) => dashboardData.connectors[c].failed),
      backgroundColor: "#ef4444",
      stack: "tests",
      yAxisID: "y",
    },
    {
      label: "Skipped/Pending",
      data: connectorNames.map(
        (c) =>
          dashboardData.connectors[c].skipped +
          dashboardData.connectors[c].pending
      ),
      backgroundColor: "#3b82f6",
      stack: "tests",
      yAxisID: "y",
    },
    {
      label: "Execution Time (min)",
      data: executionTimes,
      type: "line",
      borderColor: colors.executionLineColor,
      backgroundColor: "transparent",
      borderWidth: 2,
      pointBackgroundColor: colors.executionLineColor,
      pointBorderColor: colors.executionLineColor,
      pointRadius: 4,
      yAxisID: "y1",
    },
  ];
  if (connectorChart) {
    connectorChart.destroy();
  }
  connectorChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels: connectorNames.map((c) => toPascalCase(c)),
      datasets: datasets,
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          stacked: true,
          ticks: { color: colors.textColor },
          grid: { color: colors.gridColor },
        },
        y: {
          stacked: true,
          beginAtZero: true,
          position: "left",
          title: {
            display: true,
            text: "Number of Tests",
            color: colors.textColor,
          },
          ticks: { color: colors.textColor },
          grid: { color: colors.gridColor },
        },
        y1: {
          beginAtZero: true,
          position: "right",
          title: {
            display: true,
            text: "Time (minutes)",
            color: colors.executionLineColor,
          },
          ticks: { color: colors.executionLineColor },
          grid: { drawOnChartArea: false },
        },
      },
      plugins: {
        legend: { position: "top", labels: { color: colors.textColor } },
        tooltip: { mode: "index", intersect: false },
      },
    },
  });
}
function updateDistributionChart() {
  const ctx = document.getElementById("distributionChart").getContext("2d");
  const colors = getChartColors();
  const data = {
    labels: ["Passed", "Failed", "Skipped/Pending"],
    datasets: [
      {
        data: [
          dashboardData.totalPassed,
          dashboardData.totalFailed,
          dashboardData.totalSkipped + dashboardData.totalPending,
        ],
        backgroundColor: ["#04c38d", "#ef4444", "#3b82f6"],
      },
    ],
  };
  if (distributionChart) {
    distributionChart.destroy();
  }
  distributionChart = new Chart(ctx, {
    type: "doughnut",
    data: data,
    options: {
      responsive: true,
      maintainAspectRatio: false,
      plugins: {
        legend: { position: "right", labels: { color: colors.textColor } },
        tooltip: {
          callbacks: {
            label: function (context) {
              const label = context.label || "";
              const value = context.parsed || 0;
              const total = dashboardData.totalTests;
              const percentage = ((value / total) * 100).toFixed(1);
              return `${label}: ${value}(${percentage}%)`;
            },
          },
        },
      },
    },
  });
}
function updateAvgDurationChart() {
  const ctx = document.getElementById("avgDurationChart").getContext("2d");
  const colors = getChartColors();
  const activeConnectors = Object.entries(dashboardData.connectors).filter(
    ([, data]) => data.totalTests > 0
  );
  const connectorNames = activeConnectors.map(([name]) => name);
  const avgDurations = connectorNames.map((c) => {
    const connector = dashboardData.connectors[c];
    const totalTime = connector.executionTime || 0;
    const totalTests = connector.totalTests || 1;
    return (totalTime / totalTests / 1000).toFixed(2);
  });
  if (avgDurationChart) {
    avgDurationChart.destroy();
  }
  avgDurationChart = new Chart(ctx, {
    type: "bar",
    data: {
      labels: connectorNames.map((c) => toPascalCase(c)),
      datasets: [
        {
          label: "Average Test Duration (seconds)",
          data: avgDurations,
          backgroundColor: "#04c38d",
          borderColor: "#059669",
          borderWidth: 1,
        },
      ],
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        x: {
          ticks: { color: colors.textColor },
          grid: { color: colors.gridColor },
        },
        y: {
          beginAtZero: true,
          title: {
            display: true,
            text: "Time (seconds)",
            color: colors.textColor,
          },
          ticks: { color: colors.textColor },
          grid: { color: colors.gridColor },
        },
      },
      plugins: {
        legend: { display: false },
        tooltip: {
          callbacks: {
            label: function (context) {
              return `${context.parsed.y}seconds`;
            },
          },
        },
      },
    },
  });
}
function updateConnectorFilters() {
  const filterSelect = document.getElementById("connectorFilter");
  filterSelect.innerHTML = '<option value="">All Connectors</option>';
  Object.entries(dashboardData.connectors)
    .filter(([, data]) => data.totalTests > 0)
    .forEach(([connector]) => {
      const option = document.createElement("option");
      option.value = connector;
      option.textContent = toPascalCase(connector);
      filterSelect.appendChild(option);
    });
}
function filterData() {
  const connectorFilter = document.getElementById("connectorFilter").value;
  const statusFilter = document.getElementById("statusFilter").value;
  updateConnectorTables(connectorFilter);
  updateFailedTests(connectorFilter, statusFilter);
}
function updateConnectorTables(connectorFilter) {
  const container = document.getElementById("connectorTables");
  container.innerHTML = "";
  Object.entries(dashboardData.connectors).forEach(([connector, data]) => {
    if (connectorFilter && connector !== connectorFilter) {
      return;
    }
    if (data.totalTests === 0) {
      return;
    }
    const tableDiv = createConnectorTable(connector, data);
    container.appendChild(tableDiv);
  });
}
function createConnectorTable(connector, data) {
  const div = document.createElement("div");
  div.className = "connector-table collapsed";
  div.dataset.connector = connector;
  const header = document.createElement("h3");
  const totalCount = data.totalTests;
  const passedCount = data.passed;
  const failedCount = data.failed;
  const skippedPendingCount = data.skipped + data.pending;
  const summaryParts = [];
  summaryParts.push(`${totalCount}tests`);
  if (passedCount > 0) summaryParts.push(`${passedCount}passed`);
  if (failedCount > 0)
    summaryParts.push(
      `<span style="color: var(--error-color)">${failedCount}failed</span>`
    );
  if (skippedPendingCount > 0)
    summaryParts.push(`${skippedPendingCount}skipped`);
  if (data.executionTime) {
    const timeInMinutes = (data.executionTime / 1000 / 60).toFixed(1);
    summaryParts.push(`${timeInMinutes}min`);
  }
  header.innerHTML = ` <span style="min-width: 150px; display: inline-block;">${toPascalCase(connector)}</span> <span style="font-weight: normal; font-size: 16px; flex: 1;">(${summaryParts.join(", ")})</span> <button class="btn btn-secondary run-test-btn" onclick="event.stopPropagation(); openTestRunner('${connector}')"> Run Tests </button> `;
  header.addEventListener("click", (e) => {
    if (!e.target.classList.contains("run-test-btn")) {
      div.classList.toggle("collapsed");
    }
  });
  div.appendChild(header);
  const table = document.createElement("table");
  table.innerHTML = ` <thead> <tr> <th>Test File</th> <th>Passed</th> <th>Failed</th> <th>Skipped/Pending</th> <th>Total</th> </tr> </thead> <tbody> ${Object.entries(
    data.testsByFile
  )
    .map(([file, fileData]) => {
      const fileName = file.split("/").pop();
      const skippedPending = fileData.skipped + fileData.pending;
      return ` <tr> <td>${fileName}</td> <td><span class="status passed">${fileData.passed}</span></td> <td><span class="status failed">${fileData.failed}</span></td> <td><span class="status skipped">${skippedPending}</span></td> <td>${fileData.passed + fileData.failed + skippedPending}</td> </tr> `;
    })
    .join(
      ""
    )}</tbody> <tfoot> <tr> <th>Total</th> <th><span class="status passed">${data.passed}</span></th> <th><span class="status failed">${data.failed}</span></th> <th><span class="status skipped">${data.skipped + data.pending}</span></th> <th>${data.totalTests}</th> </tr> </tfoot> `;
  div.appendChild(table);
  return div;
}
function updateFailedTests(connectorFilter, statusFilter) {
  const container = document.getElementById("failedTestsList");
  container.innerHTML = "";
  let filteredTests = dashboardData.failedTests;
  if (connectorFilter) {
    filteredTests = filteredTests.filter(
      (test) => test.connector === connectorFilter
    );
  }
  if (statusFilter && statusFilter !== "failed") {
    document.getElementById("failedTestsSection").style.display = "none";
    return;
  }
  if (filteredTests.length === 0) {
    container.innerHTML = '<p class="text-center">No failed tests! 🎉</p>';
    document.getElementById("failedTestsSection").style.display =
      filteredTests.length === 0 && !connectorFilter ? "none" : "block";
    return;
  }
  document.getElementById("failedTestsSection").style.display = "block";
  document.getElementById("failedCount").textContent =
    `(${filteredTests.length})`;
  filteredTests.forEach((test, index) => {
    const testDiv = document.createElement("div");
    testDiv.className = "failed-test-item";
    testDiv.innerHTML = ` <h4>${index + 1}. ${test.fullTitle}</h4> <div class="failed-test-details"> <div><strong>Connector:</strong> <span>${toPascalCase(test.connector)}</span></div> <div><strong>File:</strong> <span>${test.file.split("/").pop()}</span></div> <div><strong>Duration:</strong> <span>${test.duration}ms</span></div> </div> ${test.error ? ` <div class="error-message"> ${escapeHtml(test.error.message || "No error message available")}</div> ` : ""}<div class="media-links"> ${test.screenshot ? `<a href="${test.screenshot}" target="_blank">📸 View Screenshot</a>` : ""}${test.video ? `<a href="${test.video}" target="_blank">🎥 View Video</a>` : ""}${!test.screenshot && !test.video ? '<span style="color: var(--text-secondary)">No media available</span>' : ""}</div> `;
    container.appendChild(testDiv);
  });
}
window.openTestRunner = function (connector) {
  const modal = document.getElementById("testRunnerModal");
  modal.style.display = "block";
  const connectorSelect = document.getElementById("testConnector");
  connectorSelect.innerHTML = "";
  if (connector) {
    const option = document.createElement("option");
    option.value = connector;
    option.textContent = toPascalCase(connector);
    connectorSelect.appendChild(option);
  } else {
    Object.keys(dashboardData.connectors)
      .filter((conn) => dashboardData.connectors[conn].totalTests > 0)
      .forEach((conn) => {
        const option = document.createElement("option");
        option.value = conn;
        option.textContent = toPascalCase(conn);
        connectorSelect.appendChild(option);
      });
  }
  updateTestFiles();
};
function updateTestFiles() {
  const connector = document.getElementById("testConnector").value;
  const fileSelect = document.getElementById("testFile");
  fileSelect.innerHTML = '<option value="">Select a test file</option>';
  if (connector && dashboardData.connectors[connector]) {
    Object.keys(dashboardData.connectors[connector].testsByFile).forEach(
      (file) => {
        const option = document.createElement("option");
        option.value = file;
        option.textContent = file.split("/").pop();
        fileSelect.appendChild(option);
      }
    );
  }
  updateTestCases();
}
function updateTestCases() {
  const connector = document.getElementById("testConnector").value;
  const file = document.getElementById("testFile").value;
  const caseSelect = document.getElementById("testCase");
  caseSelect.innerHTML = '<option value="">All tests in file</option>';
  if (connector && file && dashboardData.connectors[connector]) {
    const tests = dashboardData.connectors[connector].testsByFile[file].tests;
    tests.forEach((test) => {
      const option = document.createElement("option");
      option.value = test.title;
      option.textContent = test.title;
      caseSelect.appendChild(option);
    });
  }
}
async function runIndividualTest() {
  const connector = document.getElementById("testConnector").value;
  const file = document.getElementById("testFile").value;
  const testCase = document.getElementById("testCase").value;
  const output = document.getElementById("testOutput");
  if (!connector || !file) {
    alert("Please select a connector and test file");
    return;
  }
  output.innerHTML = '<div class="loading"></div> Running test...';
  try {
    const fileName = file.split("/").pop();
    const spec = testCase
      ? `--spec "**/spec${fileName}" --grep "${testCase}"`
      : `--spec "**/spec${fileName}"`;
    const command = `CYPRESS_CONNECTOR="${connector}" npm run cypress:ci -- ${spec}`;
    output.innerHTML = ` <strong>Command to run:</strong> <pre>${command}</pre> <p>To run this test, execute the above command in your terminal.</p> <p><em>Note: Real-time test execution requires a backend service to execute commands and stream results.</em></p> `;
  } catch (error) {
    output.innerHTML = `<div style="color: red;">Error: ${error.message}</div>`;
  }
}
function escapeHtml(text) {
  const div = document.createElement("div");
  div.textContent = text;
  return div.innerHTML;
}
function showError(message) {
  const container = document.querySelector(".container");
  const errorDiv = document.createElement("div");
  errorDiv.className = "error-message";
  errorDiv.style.position = "fixed";
  errorDiv.style.top = "20px";
  errorDiv.style.right = "20px";
  errorDiv.style.zIndex = "1001";
  errorDiv.textContent = message;
  container.appendChild(errorDiv);
  setTimeout(() => {
    errorDiv.remove();
  }, 5000);
}
function loadTheme() {
  const savedTheme = localStorage.getItem("dashboardTheme");
  if (savedTheme === "dark") {
    document.body.classList.add("dark-theme");
  }
}
function toggleTheme() {
  document.body.classList.toggle("dark-theme");
  const isDark = document.body.classList.contains("dark-theme");
  localStorage.setItem("dashboardTheme", isDark ? "dark" : "light");
  if (
    connectorChart ||
    distributionChart ||
    executionTimeChart ||
    avgDurationChart
  ) {
    updateCharts();
  }
}
function setupFailedTestsCollapsible() {
  const failedSection = document.getElementById("failedTestsSection");
  const header = failedSection.querySelector("h2");
  header.addEventListener("click", () => {
    failedSection.classList.toggle("collapsed");
  });
}
