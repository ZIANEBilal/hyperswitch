import { Chart as e } from "chart.js";
let t = null,
  n = null,
  o = null;
const s = null;
let a = null;
function l(e) {
  return e
    .toLowerCase()
    .split("_")
    .map((e) => e.charAt(0).toUpperCase() + e.slice(1))
    .join("");
}
function d() {
  document.getElementById("refreshBtn").addEventListener("click", i),
    document.getElementById("themeToggle").addEventListener("click", L),
    document.getElementById("connectorFilter").addEventListener("change", C),
    document.getElementById("statusFilter").addEventListener("change", C);
  const e = document.getElementById("testRunnerModal");
  (document.getElementsByClassName("close")[0].onclick = () => {
    e.style.display = "none";
  }),
    (window.onclick = (t) => {
      t.target === e && (e.style.display = "none");
    }),
    document.getElementById("runTestBtn").addEventListener("click", k),
    document.getElementById("testConnector").addEventListener("change", v),
    document.getElementById("testFile").addEventListener("change", T);
}
async function i() {
  try {
    const e = await fetch("../cypress/reports/dashboard-data.json");
    if (!e.ok) throw new Error("Failed to load dashboard data");
    (t = await e.json()), c();
  } catch (e) {
    B(
      "Failed to load dashboard data. Make sure to run the report generator first."
    );
  }
}
function c() {
  t &&
    ((document.getElementById("lastUpdated").textContent =
      `Last Test Run: ${new Date(t.timestamp).toLocaleString()}`),
    r(),
    m(),
    f(),
    C(),
    F());
}
function r() {
  const e = Object.entries(t.connectors).filter(
    ([, e]) => e.totalTests > 0
  ).length;
  document.getElementById("totalConnectors").textContent = e;
  const n = t.totalSkipped + t.totalPending;
  (document.getElementById("totalTests").textContent = t.totalTests),
    (document.getElementById("totalPassed").textContent = t.totalPassed),
    (document.getElementById("totalFailed").textContent = t.totalFailed),
    (document.getElementById("totalSkipped").textContent = n),
    (document.getElementById("successRate").textContent =
      `${t.overallSuccessRate}%`);
  const o =
    t.totalTests > 0 ? ((t.totalFailed / t.totalTests) * 100).toFixed(2) : 0;
  (document.getElementById("failureRate").textContent = `${o}%`),
    (document.getElementById("executionTime").textContent = p(t.executionTime));
}
function p(e) {
  const t = Math.floor(e / 1e3),
    n = Math.floor(t / 60),
    o = Math.floor(n / 60);
  return o > 0 ? `${o}h ${n % 60}m` : n > 0 ? `${n}m ${t % 60}s` : `${t}s`;
}
function u() {
  const e = document.body.classList.contains("dark-theme");
  return {
    textColor: e ? "#e0e0e0" : "#212529",
    gridColor: e ? "#2d2d2d" : "#e9ecef",
    executionLineColor: "#f59e0b",
    scales: {
      x: {
        ticks: { color: e ? "#e0e0e0" : "#212529" },
        grid: { color: e ? "#2d2d2d" : "#e9ecef" },
      },
      y: {
        ticks: { color: e ? "#e0e0e0" : "#212529" },
        grid: { color: e ? "#2d2d2d" : "#e9ecef" },
      },
    },
  };
}
function m() {
  g(), y(), h();
}
function g() {
  const o = document.getElementById("connectorChart").getContext("2d"),
    s = u(),
    a = Object.entries(t.connectors)
      .filter(([, e]) => e.totalTests > 0)
      .map(([e]) => e),
    d = a.map((e) =>
      ((t.connectors[e].executionTime || 0) / 1e3 / 60).toFixed(2)
    ),
    i = [
      {
        label: "Passed",
        data: a.map((e) => t.connectors[e].passed),
        backgroundColor: "#04c38d",
        stack: "tests",
        yAxisID: "y",
      },
      {
        label: "Failed",
        data: a.map((e) => t.connectors[e].failed),
        backgroundColor: "#ef4444",
        stack: "tests",
        yAxisID: "y",
      },
      {
        label: "Skipped/Pending",
        data: a.map((e) => t.connectors[e].skipped + t.connectors[e].pending),
        backgroundColor: "#3b82f6",
        stack: "tests",
        yAxisID: "y",
      },
      {
        label: "Execution Time (min)",
        data: d,
        type: "line",
        borderColor: s.executionLineColor,
        backgroundColor: "transparent",
        borderWidth: 2,
        pointBackgroundColor: s.executionLineColor,
        pointBorderColor: s.executionLineColor,
        pointRadius: 4,
        yAxisID: "y1",
      },
    ];
  n && n.destroy(),
    (n = new e(o, {
      type: "bar",
      data: { labels: a.map((e) => l(e)), datasets: i },
      options: {
        responsive: !0,
        maintainAspectRatio: !1,
        scales: {
          x: {
            stacked: !0,
            ticks: { color: s.textColor },
            grid: { color: s.gridColor },
          },
          y: {
            stacked: !0,
            beginAtZero: !0,
            position: "left",
            title: { display: !0, text: "Number of Tests", color: s.textColor },
            ticks: { color: s.textColor },
            grid: { color: s.gridColor },
          },
          y1: {
            beginAtZero: !0,
            position: "right",
            title: {
              display: !0,
              text: "Time (minutes)",
              color: s.executionLineColor,
            },
            ticks: { color: s.executionLineColor },
            grid: { drawOnChartArea: !1 },
          },
        },
        plugins: {
          legend: { position: "top", labels: { color: s.textColor } },
          tooltip: { mode: "index", intersect: !1 },
        },
      },
    }));
}
function y() {
  const n = document.getElementById("distributionChart").getContext("2d"),
    s = u(),
    a = {
      labels: ["Passed", "Failed", "Skipped/Pending"],
      datasets: [
        {
          data: [t.totalPassed, t.totalFailed, t.totalSkipped + t.totalPending],
          backgroundColor: ["#04c38d", "#ef4444", "#3b82f6"],
        },
      ],
    };
  o && o.destroy(),
    (o = new e(n, {
      type: "doughnut",
      data: a,
      options: {
        responsive: !0,
        maintainAspectRatio: !1,
        plugins: {
          legend: { position: "right", labels: { color: s.textColor } },
          tooltip: {
            callbacks: {
              label: function (e) {
                const n = e.label || "",
                  o = e.parsed || 0;
                return `${n}: ${o} (${((o / t.totalTests) * 100).toFixed(1)}%)`;
              },
            },
          },
        },
      },
    }));
}
function h() {
  const n = document.getElementById("avgDurationChart").getContext("2d"),
    o = u(),
    s = Object.entries(t.connectors)
      .filter(([, e]) => e.totalTests > 0)
      .map(([e]) => e),
    d = s.map((e) => {
      const n = t.connectors[e];
      return ((n.executionTime || 0) / (n.totalTests || 1) / 1e3).toFixed(2);
    });
  a && a.destroy(),
    (a = new e(n, {
      type: "bar",
      data: {
        labels: s.map((e) => l(e)),
        datasets: [
          {
            label: "Average Test Duration (seconds)",
            data: d,
            backgroundColor: "#04c38d",
            borderColor: "#059669",
            borderWidth: 1,
          },
        ],
      },
      options: {
        responsive: !0,
        maintainAspectRatio: !1,
        scales: {
          x: { ticks: { color: o.textColor }, grid: { color: o.gridColor } },
          y: {
            beginAtZero: !0,
            title: { display: !0, text: "Time (seconds)", color: o.textColor },
            ticks: { color: o.textColor },
            grid: { color: o.gridColor },
          },
        },
        plugins: {
          legend: { display: !1 },
          tooltip: {
            callbacks: {
              label: function (e) {
                return `${e.parsed.y} seconds`;
              },
            },
          },
        },
      },
    }));
}
function f() {
  const e = document.getElementById("connectorFilter");
  (e.innerHTML = '<option value="">All Connectors</option>'),
    Object.entries(t.connectors)
      .filter(([, e]) => e.totalTests > 0)
      .forEach(([t]) => {
        const n = document.createElement("option");
        (n.value = t), (n.textContent = l(t)), e.appendChild(n);
      });
}
function C() {
  const e = document.getElementById("connectorFilter").value,
    t = document.getElementById("statusFilter").value;
  E(e), x(e, t);
}
function E(e) {
  const n = document.getElementById("connectorTables");
  (n.innerHTML = ""),
    Object.entries(t.connectors).forEach(([t, o]) => {
      if (e && t !== e) return;
      if (0 === o.totalTests) return;
      const s = b(t, o);
      n.appendChild(s);
    });
}
function b(e, t) {
  const n = document.createElement("div");
  (n.className = "connector-table collapsed"), (n.dataset.connector = e);
  const o = document.createElement("h3"),
    s = t.totalTests,
    a = t.passed,
    d = t.failed,
    i = t.skipped + t.pending,
    c = [];
  if (
    (c.push(`${s} tests`),
    a > 0 && c.push(`${a} passed`),
    d > 0 &&
      c.push(`<span style="color: var(--error-color)">${d} failed</span>`),
    i > 0 && c.push(`${i} skipped`),
    t.executionTime)
  ) {
    const e = (t.executionTime / 1e3 / 60).toFixed(1);
    c.push(`${e} min`);
  }
  (o.innerHTML = `\n        <span style="min-width: 150px; display: inline-block;">${l(e)}</span>\n        <span style="font-weight: normal; font-size: 16px; flex: 1;">(${c.join(", ")})</span>\n        <button class="btn btn-secondary run-test-btn" onclick="event.stopPropagation(); openTestRunner('${e}')">\n            Run Tests\n        </button>\n    `),
    o.addEventListener("click", (e) => {
      e.target.classList.contains("run-test-btn") ||
        n.classList.toggle("collapsed");
    }),
    n.appendChild(o);
  const r = document.createElement("table");
  return (
    (r.innerHTML = `\n        <thead>\n            <tr>\n                <th>Test File</th>\n                <th>Passed</th>\n                <th>Failed</th>\n                <th>Skipped/Pending</th>\n                <th>Total</th>\n            </tr>\n        </thead>\n        <tbody>\n            ${Object.entries(
      t.testsByFile
    )
      .map(([e, t]) => {
        const n = e.split("/").pop(),
          o = t.skipped + t.pending;
        return `\n                        <tr>\n                            <td>${n}</td>\n                            <td><span class="status passed">${t.passed}</span></td>\n                            <td><span class="status failed">${t.failed}</span></td>\n                            <td><span class="status skipped">${o}</span></td>\n                            <td>${t.passed + t.failed + o}</td>\n                        </tr>\n                    `;
      })
      .join(
        ""
      )}\n        </tbody>\n        <tfoot>\n            <tr>\n                <th>Total</th>\n                <th><span class="status passed">${t.passed}</span></th>\n                <th><span class="status failed">${t.failed}</span></th>\n                <th><span class="status skipped">${t.skipped + t.pending}</span></th>\n                <th>${t.totalTests}</th>\n            </tr>\n        </tfoot>\n    `),
    n.appendChild(r),
    n
  );
}
function x(e, n) {
  const o = document.getElementById("failedTestsList");
  o.innerHTML = "";
  let s = t.failedTests;
  if ((e && (s = s.filter((t) => t.connector === e)), n && "failed" !== n))
    document.getElementById("failedTestsSection").style.display = "none";
  else {
    if (0 === s.length)
      return (
        (o.innerHTML = '<p class="text-center">No failed tests! 🎉</p>'),
        void (document.getElementById("failedTestsSection").style.display =
          0 !== s.length || e ? "block" : "none")
      );
    (document.getElementById("failedTestsSection").style.display = "block"),
      (document.getElementById("failedCount").textContent = `(${s.length})`),
      s.forEach((e, t) => {
        const n = document.createElement("div");
        (n.className = "failed-test-item"),
          (n.innerHTML = `\n            <h4>${t + 1}. ${e.fullTitle}</h4>\n            <div class="failed-test-details">\n                <div><strong>Connector:</strong> <span>${l(e.connector)}</span></div>\n                <div><strong>File:</strong> <span>${e.file.split("/").pop()}</span></div>\n                <div><strong>Duration:</strong> <span>${e.duration}ms</span></div>\n            </div>\n            ${e.error ? `\n                <div class="error-message">\n                    ${$(e.error.message || "No error message available")}\n                </div>\n            ` : ""}\n            <div class="media-links">\n                ${e.screenshot ? `<a href="${e.screenshot}" target="_blank">📸 View Screenshot</a>` : ""}\n                ${e.video ? `<a href="${e.video}" target="_blank">🎥 View Video</a>` : ""}\n                ${e.screenshot || e.video ? "" : '<span style="color: var(--text-secondary)">No media available</span>'}\n            </div>\n        `),
          o.appendChild(n);
      });
  }
}
function v() {
  const e = document.getElementById("testConnector").value,
    n = document.getElementById("testFile");
  (n.innerHTML = '<option value="">Select a test file</option>'),
    e &&
      t.connectors[e] &&
      Object.keys(t.connectors[e].testsByFile).forEach((e) => {
        const t = document.createElement("option");
        (t.value = e), (t.textContent = e.split("/").pop()), n.appendChild(t);
      }),
    T();
}
function T() {
  const e = document.getElementById("testConnector").value,
    n = document.getElementById("testFile").value,
    o = document.getElementById("testCase");
  if (
    ((o.innerHTML = '<option value="">All tests in file</option>'),
    e && n && t.connectors[e])
  ) {
    t.connectors[e].testsByFile[n].tests.forEach((e) => {
      const t = document.createElement("option");
      (t.value = e.title), (t.textContent = e.title), o.appendChild(t);
    });
  }
}
async function k() {
  const e = document.getElementById("testConnector").value,
    t = document.getElementById("testFile").value,
    n = document.getElementById("testCase").value,
    o = document.getElementById("testOutput");
  if (e && t) {
    o.innerHTML = '<div class="loading"></div> Running test...';
    try {
      const s = t.split("/").pop(),
        a = `CYPRESS_CONNECTOR="${e}" npm run cypress:ci -- ${n ? `--spec "**/spec/**/${s}" --grep "${n}"` : `--spec "**/spec/**/${s}"`}`;
      o.innerHTML = `\n            <strong>Command to run:</strong>\n            <pre>${a}</pre>\n\n            <p>To run this test, execute the above command in your terminal.</p>\n\n            <p><em>Note: Real-time test execution requires a backend service to execute commands and stream results.</em></p>\n        `;
    } catch (e) {
      o.innerHTML = `<div style="color: red;">Error: ${e.message}</div>`;
    }
  } else alert("Please select a connector and test file");
}
function $(e) {
  const t = document.createElement("div");
  return (t.textContent = e), t.innerHTML;
}
function B(e) {
  const t = document.querySelector(".container"),
    n = document.createElement("div");
  (n.className = "error-message"),
    (n.style.position = "fixed"),
    (n.style.top = "20px"),
    (n.style.right = "20px"),
    (n.style.zIndex = "1001"),
    (n.textContent = e),
    t.appendChild(n),
    setTimeout(() => {
      n.remove();
    }, 5e3);
}
function I() {
  "dark" === localStorage.getItem("dashboardTheme") &&
    document.body.classList.add("dark-theme");
}
function L() {
  document.body.classList.toggle("dark-theme");
  const e = document.body.classList.contains("dark-theme");
  localStorage.setItem("dashboardTheme", e ? "dark" : "light"),
    (n || o || a) && m();
}
function F() {
  const e = document.getElementById("failedTestsSection");
  e.querySelector("h2").addEventListener("click", () => {
    e.classList.toggle("collapsed");
  });
}
document.addEventListener("DOMContentLoaded", () => {
  I(), i(), d(), setInterval(i, 3e4);
}),
  (window.openTestRunner = function (e) {
    document.getElementById("testRunnerModal").style.display = "block";
    const n = document.getElementById("testConnector");
    if (((n.innerHTML = ""), e)) {
      const t = document.createElement("option");
      (t.value = e), (t.textContent = l(e)), n.appendChild(t);
    } else
      Object.keys(t.connectors)
        .filter((e) => t.connectors[e].totalTests > 0)
        .forEach((e) => {
          const t = document.createElement("option");
          (t.value = e), (t.textContent = l(e)), n.appendChild(t);
        });
    v();
  });
